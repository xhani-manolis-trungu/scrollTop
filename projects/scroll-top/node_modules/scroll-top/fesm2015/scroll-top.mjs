import * as i0 from '@angular/core';
import { isDevMode, Injectable, Directive, Input, HostListener, Component, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

class ScrollTopService {
    constructor() {
        this.isDevMode = isDevMode();
        this.isWindow = typeof window !== 'undefined';
        this._init = false;
        this.lastY = 0;
        this.ticking = false;
        this.log = (s, ...optional) => s && this.isDevMode && console.log(s, optional);
        this.handleScroll = () => {
            if (!this.ticking) {
                window.requestAnimationFrame(() => {
                    this.updateLastY();
                    this.ticking = false;
                });
                this.ticking = true;
            }
        };
    }
    get currentPositionY() {
        return this._elementToScroll ? this._elementToScroll.scrollTop : window.pageYOffset;
    }
    get info() { return Math.ceil(this.lastY); }
    setDevMode() { this.isDevMode = true; }
    init(elementId) {
        if (this.isWindow) {
            this.destroy();
            this._elementToScroll = null;
            if (elementId) {
                this._elementToScroll = document.querySelector(`#${elementId}`);
            }
            this._host = this._elementToScroll || window;
            this._host.addEventListener('scroll', this.handleScroll);
            this.log(`'NgScrolltopService' to use ${this._elementToScroll ? 'element' : 'window'}`, elementId || '');
        }
        this._init = true;
    }
    destroy() {
        this.isWindow && this._host && this._host.removeEventListener('scroll', this.handleScroll);
    }
    scrollABit(newY) {
        if (this._elementToScroll) {
            this._elementToScroll.scrollTop = newY;
        }
        else {
            window.scroll(0, newY);
        }
    }
    updateLastY() {
        if (!this._init)
            return;
        const newY = this.currentPositionY;
        if (newY !== this.lastY) {
            this.lastY = newY;
        }
    }
}
ScrollTopService.ɵfac = function ScrollTopService_Factory(t) { return new (t || ScrollTopService)(); };
ScrollTopService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ScrollTopService, factory: ScrollTopService.ɵfac, providedIn: 'root' });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ScrollTopService, [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], function () { return []; }, null);
})();

const DURATION = 1000;
class ScrollTopDirective {
    constructor(service, ngZone) {
        this.service = service;
        this.ngZone = ngZone;
        this.progress = 0;
        this.easing = (x) => {
            'use strict';
            if (x < 0.5) {
                return Math.pow(x * 2, 2) / 2;
            }
            return 1 - Math.pow((1 - x) * 2, 2) / 2;
        };
        this.scrollABit = this.scrollABit.bind(this);
    }
    onclick($event) {
        this.startTop = this.service.currentPositionY;
        this.startTime = null;
        if (this.targetElementExists($event, this.targetElement)) {
            this.ngZone.runOutsideAngular(() => { window.requestAnimationFrame(this.scrollABit); });
        }
        this.service.log('NgScrolltopDirective click');
    }
    targetElementExists($event, selector) {
        let found = false;
        if ($event === null || $event === void 0 ? void 0 : $event.target.matches(`#${selector}, #${selector} > *`)) {
            found = true;
        }
        return found;
    }
    scrollABit(timestamp) {
        if (!this.startTime) {
            this.startTime = timestamp;
        }
        this.progress = timestamp - this.startTime;
        const percent = (this.progress >= DURATION ? 1 : this.easing(this.progress / DURATION));
        const newY = this.startTop - Math.ceil(this.startTop * percent);
        this.service.scrollABit(newY);
        if (percent < 1) {
            this.ngZone.runOutsideAngular(() => { window.requestAnimationFrame(this.scrollABit); });
        }
    }
}
ScrollTopDirective.ɵfac = function ScrollTopDirective_Factory(t) { return new (t || ScrollTopDirective)(i0.ɵɵdirectiveInject(ScrollTopService), i0.ɵɵdirectiveInject(i0.NgZone)); };
ScrollTopDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ScrollTopDirective, selectors: [["", "blScrolltop", ""]], hostBindings: function ScrollTopDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵlistener("click", function ScrollTopDirective_click_HostBindingHandler($event) { return ctx.onclick($event); });
        }
    }, inputs: { targetElement: "targetElement" } });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ScrollTopDirective, [{
            type: Directive,
            args: [{
                    selector: '[blScrolltop]'
                }]
        }], function () { return [{ type: ScrollTopService }, { type: i0.NgZone }]; }, { targetElement: [{
                type: Input,
                args: ['targetElement']
            }], onclick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] });
})();

class ScrollTopComponent {
    constructor(service) {
        this.service = service;
    }
    set elementId(value) {
        this._elementId = value;
        this.service.init(value);
    }
    ngOnInit() {
        this.service.init(this._elementId);
    }
    ngOnDestroy() {
        this.service.destroy();
    }
}
ScrollTopComponent.ɵfac = function ScrollTopComponent_Factory(t) { return new (t || ScrollTopComponent)(i0.ɵɵdirectiveInject(ScrollTopService)); };
ScrollTopComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ScrollTopComponent, selectors: [["lib-scroll-top"]], inputs: { elementId: "elementId" }, features: [i0.ɵɵProvidersFeature([ScrollTopDirective])], decls: 1, vars: 0, consts: [[1, "scroll-top"]], template: function ScrollTopComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵelement(0, "div", 0);
        }
    }, encapsulation: 2 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ScrollTopComponent, [{
            type: Component,
            args: [{
                    selector: 'lib-scroll-top',
                    template: `
    <div class="scroll-top" ></div>
  `,
                    providers: [ScrollTopDirective]
                }]
        }], function () { return [{ type: ScrollTopService }]; }, { elementId: [{
                type: Input
            }] });
})();

class ScrollTopModule {
}
ScrollTopModule.ɵfac = function ScrollTopModule_Factory(t) { return new (t || ScrollTopModule)(); };
ScrollTopModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: ScrollTopModule });
ScrollTopModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [CommonModule] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ScrollTopModule, [{
            type: NgModule,
            args: [{
                    declarations: [
                        ScrollTopComponent,
                        ScrollTopDirective
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        ScrollTopComponent,
                        ScrollTopDirective
                    ]
                }]
        }], null, null);
})();
(function () {
    (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(ScrollTopModule, { declarations: [ScrollTopComponent,
            ScrollTopDirective], imports: [CommonModule], exports: [ScrollTopComponent,
            ScrollTopDirective] });
})();

/*
 * Public API Surface of scroll-top
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ScrollTopComponent, ScrollTopDirective, ScrollTopModule, ScrollTopService };
//# sourceMappingURL=scroll-top.mjs.map
